{"version":3,"sources":["index.js"],"names":["_interopRequireDefault","obj","__esModule","default","_classCallCheck","instance","Constructor","TypeError","Object","defineProperty","exports","value","_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","key","protoProps","staticProps","prototype","_moment","require","_moment2","IntervalRecurrence","_ref","interval","recurrence","_ref$strict","strict","undefined","this","_parseISO8601","Error","date","_calculateRecurrence","containsDate","_calculateRecurrence2","whichRecurrence","remainder","timeBeforeStart","duration","asMilliseconds","start","clone","add","end","toDate","difference","diff","recurring_period","Infinity","Math","floor","arguments","split","e","dateObject","substring","Number","parseInt","isNaN","shift","date0","isDate0","ISO_8601","isValid","isInterval0","date1","isDate1","isInterval1","subtract","module"],"mappings":"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","file":"index.js","sourcesContent":["'use strict';\n\nimport moment from 'moment';\n\nexport default class IntervalRecurrence {\n\tconstructor ({ interval, recurrence, strict = true }) {\n\n\t\tif (!recurrence) {\n\t\t\t// A falsy recurrence value just means no recurrence.\n\t\t\trecurrence = 'R0';\n\t\t}\n\n\t\tinterval = this._parseISO8601(interval, strict);\n\t\trecurrence = this._parseISO8601(recurrence, strict);\n\n\t\t// Deal with various invalid inputs...\n\n\t\t// Interval will return false if it is invalid.\n\t\tif (!interval) {\n\t\t\tthrow Error('Invalid interval.');\n\t\t}\n\n\t\t// The interval must have a date, an interval and no recurrence.\n\t\tif (interval.recurrence !== undefined || interval.date === undefined || interval.interval === undefined) {\n\t\t\tthrow Error('Interval must have a date, an interval and no recurrence.');\n\t\t}\n\n\t\t// Recurrence will return false if it is invalid.\n\t\tif (!recurrence) {\n\t\t\tthrow Error('Invalid recurrence.');\n\t\t}\n\n\t\t// The recurrence must have a recurrence and no date.\n\t\tif (recurrence.recurrence === undefined || recurrence.date !== undefined) {\n\t\t\tthrow Error('Recurrence must have a recurrence, an interval and no date.');\n\t\t}\n\n\t\t// Recurrence can only have no interval if the recurrence is 0.\n\t\tif (recurrence.interval === undefined && recurrence.recurrence !== 0) {\n\t\t\tthrow Error('Recurrence can only have no interval if the recurrence is 0.');\n\t\t}\n\n\t\tthis.interval = interval;\n\t\tthis.recurrence = recurrence;\n\t\t// When Babel supports it use:\n\t\t// Object.assign(this, { interval, recurrence });\n\t}\n\n\tcontainsDate (date) {\n\t\treturn this._calculateRecurrence(date).containsDate;\n\t}\n\n\tcurrentRange (date) {\n\t\tvar { whichRecurrence, remainder, containsDate } = this._calculateRecurrence(date);\n\n\t\tif (!containsDate) {\n\t\t\treturn false;\n\t\t}\n\n\t\tvar timeBeforeStart = moment.duration(this.recurrence.interval).asMilliseconds() * whichRecurrence;\n\n\t\t// Note that we need to clone these moments because they are mutable.\n\t\tvar start = this.interval.date.clone().add(timeBeforeStart, 'milliseconds');\n\t\tvar end = start.clone().add(this.interval.interval);\n\n\t\t// We return them as JavaScript Dates for library interoperability.\n\t\treturn {\n\t\t\tstart: start.toDate(),\n\t\t\tend: end.toDate()\n\t\t};\n\t}\n\n\t_calculateRecurrence (date) {\n\t\tdate = moment(date);\n\n\t\t// Calculate what recurrence we are in.\n\t\tvar difference = date.diff(this.interval.date);\n\t\tvar recurring_period = (this.recurrence.interval !== undefined) ? this.recurrence.interval.asMilliseconds() : 0;\n\n\t\tif (recurring_period === 0) {\n\t\t\trecurring_period = Infinity;\n\t\t}\n\n\t\tvar whichRecurrence = Math.floor(difference / recurring_period);\n\t\tvar remainder = difference % recurring_period;\n\n\t\tvar containsDate;\n\n\t\tif ( (whichRecurrence > this.recurrence.recurrence) ) {\n\t\t\t// Check we're within allowed recurrences.\n\t\t\t// An value of Infinity suggests that the recurrence interval is zero.\n\t\t\tcontainsDate = false;\n\t\t} else if (remainder > this.interval.interval.asMilliseconds()) {\n\t\t\t// Finally check whether we are in the interval for this recurrence.\n\t\t\tcontainsDate = false;\n\t\t} else {\n\t\t\t// If we got here it must be true, right?\n\t\t\tcontainsDate = true;\n\t\t}\n\n\t\treturn { whichRecurrence, remainder, containsDate };\n\t}\n\n\t_parseISO8601 (date, strict = true) {\n\t\t// Split the date string by slashes.\n\t\ttry {\n\t\t\tdate = date.split('/');\n\t\t} catch (e) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Begin the object that we will return with the constitutent parts.\n\t\tvar dateObject = {};\n\n\t\t// First deal with number of repetitions, if any.\n\t\tif (date[0].substring(0, 1) === 'R') {\n\t\t\tvar recurrence = date[0].substring(1);\n\t\t\tif (recurrence === '') {\n\t\t\t\tdateObject.recurrence = Infinity;\n\t\t\t} else {\n\t\t\t\trecurrence = Number.parseInt(recurrence);\n\t\t\t\tif (!Number.isNaN(recurrence)) {\n\t\t\t\t\tdateObject.recurrence = recurrence;\n\t\t\t\t} else {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// The number of repetitions are then removed from the array.\n\t\t\tdate.shift();\n\t\t}\n\n\t\t// If we have a zero length array, it's only ok if there has been a\n\t\t// recurrence. We technically want this to be a recurrence of zero,\n\t\t// but that is done in the constructor instead of here as a solo\n\t\t// recurrence that does not equal zer0 may be of some meaning to\n\t\t// other applicatons of this parsing function.\n\t\tif (date.length === 0) {\n\t\t\treturn dateObject;\n\t\t}\n\n\t\t// Make some prelimiary determinations about the first index of the array.\n\t\t// Here we build a moment Object ahead of time, and check the validity of the\n\t\t// first index as a date or interval.\n\t\tvar date0;\n\t\tvar isDate0;\n\t\ttry {\n\t\t\tdate0 = moment(date[0], moment.ISO_8601, strict);\n\t\t\tisDate0 = date0.isValid();\n\t\t} catch (e) {\n\t\t\tdate0 = false;\n\t\t\tisDate0 = false;\n\t\t}\n\t\tvar isInterval0 = (date[0].substring(0, 1) === 'P') && (moment.duration(date[0]) > 0);\n\n\t\tif (date.length === 2) {\n\t\t\t// If the lenght of the array is two, there is more to do. We make the same\n\t\t\t// preliminary determinations about the second index.\n\t\t\tvar date1;\n\t\t\tvar isDate1;\n\t\t\ttry {\n\t\t\t\tdate1 = moment(date[1], moment.ISO_8601, strict);\n\t\t\t\tisDate1 = date1.isValid();\n\t\t\t} catch (e) {\n\t\t\t\tdate1 = false;\n\t\t\t\tisDate1 = false;\n\t\t\t}\n\t\t\tvar isInterval1 = (date[1].substring(0, 1) === 'P') && (moment.duration(date[1]) > 0);\n\n\t\t\tif (isDate0 && isDate1) {\n\t\t\t\t// If they are both valid dates...\n\t\t\t\tif (dateObject.recurrence !== undefined) {\n\t\t\t\t\t// ... with a repetition that is invalid.\n\t\t\t\t\treturn false;\n\t\t\t\t} else {\n\t\t\t\t\t// ... we can turn the second date into a period.\n\t\t\t\t\tdateObject.date = date0;\n\t\t\t\t\tdateObject.interval = moment.duration(date1.diff(date0));\n\t\t\t\t\treturn dateObject;\n\t\t\t\t}\n\t\t\t} else if (isDate0 && isInterval1) {\n\t\t\t\t// If the first is a date and the second an interval, we have a basic\n\t\t\t\t// ISO8601 interval with a start date.\n\t\t\t\tdateObject.date = date0;\n\t\t\t\tdateObject.interval = moment.duration(date[1]);\n\t\t\t\treturn dateObject;\n\t\t\t} else if (isInterval0 && isDate1) {\n\t\t\t\t// If the first is an interval and the second is a date, we have a\n\t\t\t\t// more complicated interval with an end date. However, we can just\n\t\t\t\t// invert the sign on the interval and treat it like normal.\n\t\t\t\tvar interval = moment.duration(date[0]);\n\n\t\t\t\tdateObject.date = date1.subtract(interval);\n\t\t\t\tdateObject.interval = interval;\n\t\t\t\treturn dateObject;\n\t\t\t} else {\n\t\t\t\t// Any other form of a two-length array must be invalid.\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else if (date.length === 1) {\n\t\t\t// If the length of the array is one, we may be looking at some trivial dates.\n\t\t\tif (isDate0) {\n\t\t\t\t// If the value is a valid date...\n\t\t\t\tif (dateObject.recurrence) {\n\t\t\t\t\t// ... it is invalid with a repetition.\n\t\t\t\t\treturn false;\n\t\t\t\t} else {\n\t\t\t\t\t// ... we can just return it.\n\t\t\t\t\tdateObject.date = date0;\n\t\t\t\t\treturn dateObject;\n\t\t\t\t}\n\t\t\t} else if (isInterval0) {\n\t\t\t\t// An interval on its own is valid, as is it with a repetition.\n\t\t\t\tdateObject.interval = moment.duration(date[0]);\n\t\t\t\treturn dateObject;\n\t\t\t} else {\n\t\t\t\t// All other formations are invalid.\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else {\n\t\t\t// Any other array lenghts at this stage are invalid.\n\t\t\treturn false;\n\t\t}\n\t}\n}\n"],"sourceRoot":"/source/"}