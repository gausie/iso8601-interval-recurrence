{"version":3,"sources":["index.js"],"names":["_interopRequireDefault","obj","__esModule","default","_classCallCheck","instance","Constructor","TypeError","Object","defineProperty","exports","value","_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","key","protoProps","staticProps","prototype","_moment","require","_moment2","IntervalRecurrence","range","this","interval","recurrence","_parseISO8601","Error","undefined","date","_calculateRecurrence","containsDate","_calculateRecurrence2","whichRecurrence","remainder","timeBeforeStart","duration","asMilliseconds","start","clone","add","end","toDate","difference","diff","recurring_period","Infinity","Math","floor","split","dateObject","substring","Number","parseInt","isNaN","shift","date0","ISO_8601","isDate0","isValid","isInterval0","date1","isDate1","isInterval1","subtract","module"],"mappings":"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","file":"index.js","sourcesContent":["'use strict';\n\nimport moment from 'moment';\n\nexport default class IntervalRecurrence {\n\tconstructor (range) {\n\t\tvar { interval, recurrence } = range;\n\n\t\tif (!recurrence) {\n\t\t\t// A falsy recurrence value just means no recurrence.\n\t\t\trecurrence = 'R0';\n\t\t}\n\n\t\tinterval = this._parseISO8601(interval);\n\t\trecurrence = this._parseISO8601(recurrence);\n\n\t\t// Deal with various invalid inputs...\n\n\t\t// Interval will return false if it is invalid.\n\t\tif (!interval) {\n\t\t\tthrow Error('Invalid interval.');\n\t\t}\n\n\t\t// The interval must have a date, an interval and no recurrence.\n\t\tif (interval.recurrence !== undefined || interval.date === undefined || interval.interval === undefined) {\n\t\t\tthrow Error('Interval must have a date, an interval and no recurrence.');\n\t\t}\n\n\t\t// Recurrence will return false if it is invalid.\n\t\tif (!recurrence) {\n\t\t\tthrow Error('Invalid recurrence.');\n\t\t}\n\n\t\t// The recurrence must have a recurrence and no date.\n\t\tif (recurrence.recurrence === undefined || recurrence.date !== undefined) {\n\t\t\tthrow Error('Recurrence must have a recurrence, an interval and no date.');\n\t\t}\n\n\t\t// Recurrence can only have no interval if the recurrence is 0.\n\t\tif (recurrence.interval === undefined && recurrence.recurrence !== 0) {\n\t\t\tthrow Error('Recurrence can only have no interval if the recurrence is 0.');\n\t\t}\n\n\t\tthis.interval = interval;\n\t\tthis.recurrence = recurrence;\n\t\t// When Babel supports it use:\n\t\t// Object.assign(this, { interval, recurrence });\n\t}\n\n\tcontainsDate (date) {\n\t\treturn this._calculateRecurrence(date).containsDate;\n\t}\n\n\tcurrentRange (date) {\n\t\tvar { whichRecurrence, remainder, containsDate } = this._calculateRecurrence(date);\n\n\t\tif (!containsDate) {\n\t\t\treturn false;\n\t\t}\n\n\t\tvar timeBeforeStart = moment.duration(this.recurrence.interval).asMilliseconds() * whichRecurrence;\n\n\t\t// Note that we need to clone these moments because they are mutable.\n\t\tvar start = this.interval.date.clone().add(timeBeforeStart, 'milliseconds');\n\t\tvar end = start.clone().add(this.interval.interval);\n\n\t\t// We return them as JavaScript Dates for library interoperability.\n\t\treturn {\n\t\t\tstart: start.toDate(),\n\t\t\tend: end.toDate()\n\t\t};\n\t}\n\n\t_calculateRecurrence (date) {\n\t\tdate = moment(date);\n\n\t\t// Calculate what recurrence we are in.\n\t\tvar difference = date.diff(this.interval.date);\n\t\tvar recurring_period = (this.recurrence.interval !== undefined) ? this.recurrence.interval.asMilliseconds() : 0;\n\n\t\tif (recurring_period === 0) {\n\t\t\trecurring_period = Infinity;\n\t\t}\n\n\t\tvar whichRecurrence = Math.floor(difference / recurring_period);\n\t\tvar remainder = difference % recurring_period;\n\n\t\tvar containsDate;\n\n\t\tif ( (whichRecurrence > this.recurrence.recurrence) ) {\n\t\t\t// Check we're within allowed recurrences.\n\t\t\t// An value of Infinity suggests that the recurrence interval is zero.\n\t\t\tcontainsDate = false;\n\t\t} else if (remainder > this.interval.interval.asMilliseconds()) {\n\t\t\t// Finally check whether we are in the interval for this recurrence.\n\t\t\tcontainsDate = false;\n\t\t} else {\n\t\t\t// If we got here it must be true, right?\n\t\t\tcontainsDate = true;\n\t\t}\n\n\t\treturn { whichRecurrence, remainder, containsDate };\n\t}\n\n\t_parseISO8601 (date) {\n\t\t// Split the date string by slashes.\n\t\tdate = date.split('/');\n\n\t\t// Begin the object that we will return with the constitutent parts.\n\t\tvar dateObject = {};\n\n\t\t// First deal with number of repetitions, if any.\n\t\tif (date[0].substring(0, 1) === 'R') {\n\t\t\tvar recurrence = date[0].substring(1);\n\t\t\tif (recurrence === '') {\n\t\t\t\tdateObject.recurrence = Infinity;\n\t\t\t} else {\n\t\t\t\trecurrence = Number.parseInt(recurrence);\n\t\t\t\tif (!Number.isNaN(recurrence)) {\n\t\t\t\t\tdateObject.recurrence = recurrence;\n\t\t\t\t} else {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// The number of repetitions are then removed from the array.\n\t\t\tdate.shift();\n\t\t}\n\n\t\t// If we have a zero length array, it's only ok if there has been a\n\t\t// zero recurrence.\n\t\tif (date.length === 0) {\n\t\t\tif (dateObject.recurrence === 0) {\n\t\t\t\treturn dateObject;\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t// Make some prelimiary determinations about the first index of the array.\n\t\t// Here we build a moment Object ahead of time, and check the validity of the\n\t\t// first index as a date or interval.\n\t\tvar date0 = moment(date[0], moment.ISO_8601, true);\n\t\tvar isDate0 = date0.isValid();\n\t\tvar isInterval0 = (date[0].substring(0, 1) === 'P') && (moment.duration(date[0]) > 0);\n\n\t\tif (date.length === 2) {\n\t\t\t// If the lenght of the array is two, there is more to do. We make the same\n\t\t\t// preliminary determinations about the second index.\n\t\t\tvar date1 = moment(date[1], moment.ISO_8601, true);\n\t\t\tvar isDate1 = date1.isValid();\n\t\t\tvar isInterval1 = (date[1].substring(0, 1) === 'P') && (moment.duration(date[1]) > 0);\n\n\t\t\tif (isDate0 && isDate1) {\n\t\t\t\t// If they are both valid dates...\n\t\t\t\tif (date.recurrence) {\n\t\t\t\t\t// ... with a repetition that is invalid.\n\t\t\t\t\treturn false;\n\t\t\t\t} else {\n\t\t\t\t\t// ... we can turn the second date into a period.\n\t\t\t\t\tdateObject.date = date0;\n\t\t\t\t\tdateObject.interval = moment.duration(date1.diff(date0));\n\t\t\t\t\treturn dateObject;\n\t\t\t\t}\n\t\t\t} else if (isDate0 && isInterval1) {\n\t\t\t\t// If the first is a date and the second an interval, we have a basic\n\t\t\t\t// ISO8601 interval with a start date.\n\t\t\t\tdateObject.date = date0;\n\t\t\t\tdateObject.interval = moment.duration(date[1]);\n\t\t\t\treturn dateObject;\n\t\t\t} else if (isInterval0 && isDate1) {\n\t\t\t\t// If the first is an interval and the second is a date, we have a\n\t\t\t\t// more complicated interval with an end date. However, we can just\n\t\t\t\t// invert the sign on the interval and treat it like normal.\n\t\t\t\tvar interval = moment.duration(date[0]);\n\n\t\t\t\tdateObject.date = date1.subtract(interval);\n\t\t\t\tdateObject.interval = interval;\n\t\t\t\treturn dateObject;\n\t\t\t} else {\n\t\t\t\t// Any other form of a two-length array must be invalid.\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else if (date.length === 1) {\n\t\t\t// If the length of the array is one, we may be looking at some trivial dates.\n\t\t\tif (isDate0) {\n\t\t\t\t// If the value is a valid date...\n\t\t\t\tif (dateObject.recurrence) {\n\t\t\t\t\t// ... it is invalid with a repetition.\n\t\t\t\t\treturn false;\n\t\t\t\t} else {\n\t\t\t\t\t// ... we can just return it.\n\t\t\t\t\tdateObject.date = date0;\n\t\t\t\t\treturn dateObject;\n\t\t\t\t}\n\t\t\t} else if (isInterval0) {\n\t\t\t\t// An interval on its own is valid, as is it with a repetition.\n\t\t\t\tdateObject.interval = moment.duration(date[0]);\n\t\t\t\treturn dateObject;\n\t\t\t} else {\n\t\t\t\t// All other formations are invalid.\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else {\n\t\t\t// Any other array lenghts at this stage are invalid.\n\t\t\treturn false;\n\t\t}\n\t}\n}\n"],"sourceRoot":"/source/"}