{"version":3,"sources":["index.js"],"names":["_interopRequireDefault","obj","__esModule","default","_classCallCheck","instance","Constructor","TypeError","Object","defineProperty","exports","value","_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","key","protoProps","staticProps","prototype","_moment","require","_moment2","IntervalRecurrence","range","this","interval","recurrence","_parseISO8601","Error","undefined","date","_calculateRecurrence","containsDate","_calculateRecurrence2","whichRecurrence","remainder","timeBeforeStart","duration","asMilliseconds","start","add","end","difference","diff","recurring_period","Infinity","Math","floor","split","dateObject","substring","Number","parseInt","isNaN","shift","date0","ISO_8601","isDate0","isValid","isInterval0","date1","isDate1","isInterval1","toJSON","subtract","toISOString","module"],"mappings":"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","file":"index.js","sourcesContent":["'use strict';\n\nimport moment from 'moment';\n\nexport default class IntervalRecurrence {\n\tconstructor (range) {\n\t\tvar { interval, recurrence } = range;\n\n\t\tif (!recurrence) {\n\t\t\t// A falsy recurrence value just means no recurrence.\n\t\t\trecurrence = 'R0';\n\t\t}\n\n\t\tinterval = this._parseISO8601(interval);\n\t\trecurrence = this._parseISO8601(recurrence);\n\n\t\t// Deal with various invalid inputs...\n\n\t\t// Interval will return false if it is invalid.\n\t\tif (!interval) {\n\t\t\tthrow Error('Invalid interval.');\n\t\t}\n\n\t\t// The interval must have a date, an interval and no recurrence.\n\t\tif (interval.recurrence !== undefined || interval.date === undefined || interval.interval === undefined) {\n\t\t\tthrow Error('Interval must have a date, an interval and no recurrence.');\n\t\t}\n\n\t\t// Recurrence will return false if it is invalid.\n\t\tif (!recurrence) {\n\t\t\tthrow Error('Invalid recurrence.');\n\t\t}\n\n\t\t// The recurrence must have a recurrence and no date.\n\t\tif (recurrence.recurrence === undefined || recurrence.date !== undefined) {\n\t\t\tthrow Error('Recurrence must have a recurrence, an interval and no date.');\n\t\t}\n\n\t\t// Recurrence can only have no interval if the recurrence is 0.\n\t\tif (recurrence.interval === undefined && recurrence.recurrence !== 0) {\n\t\t\tthrow Error('Recurrence can only have no interval if the recurrence is 0.');\n\t\t}\n\n\t\tthis.interval = interval;\n\t\tthis.recurrence = recurrence;\n\t\t// When Babel supports it use:\n\t\t// Object.assign(this, { interval, recurrence });\n\t}\n\n\tcontainsDate (date) {\n\t\treturn this._calculateRecurrence(date).containsDate;\n\t}\n\n\tcurrentRange (date) {\n\t\tvar { whichRecurrence, remainder, containsDate } = this._calculateRecurrence(date);\n\n\t\tif (!containsDate) {\n\t\t\treturn false;\n\t\t}\n\n\t\tvar timeBeforeStart = moment.duration(this.recurrence.interval).asMilliseconds() * whichRecurrence;\n\n\t\tvar start = moment(this.interval.date).add(timeBeforeStart, 'milliseconds');\n\t\tvar end = start.add(moment.duration(this.interval.interval));\n\n\t\treturn { start, end };\n\t}\n\n\t_calculateRecurrence (date) {\n\t\tdate = moment(date);\n\n\t\t// Calculate what recurrence we are in.\n\t\tvar difference = date.diff(moment(this.interval.date));\n\t\tvar recurring_period = moment.duration(this.recurrence.interval).asMilliseconds();\n\n\t\tif (recurring_period === 0) {\n\t\t\trecurring_period = Infinity;\n\t\t}\n\n\t\tvar whichRecurrence = Math.floor(difference / recurring_period);\n\t\tvar remainder = difference % recurring_period;\n\n\t\tvar containsDate;\n\n\t\tif ( (whichRecurrence > this.recurrence.recurrence) ) {\n\t\t\t// Check we're within allowed recurrences.\n\t\t\t// An value of Infinity suggests that the recurrence interval is zero.\n\t\t\tcontainsDate = false;\n\t\t} else if (remainder > moment.duration(this.interval.interval).asMilliseconds()) {\n\t\t\t// Finally check whether we are in the interval for this recurrence.\n\t\t\tcontainsDate = false;\n\t\t} else {\n\t\t\t// If we got here it must be true, right?\n\t\t\tcontainsDate = true;\n\t\t}\n\n\n\t\treturn { whichRecurrence, remainder, containsDate };\n\t}\n\n\t_parseISO8601 (date) {\n\t\t// Split the date string by slashes.\n\t\tdate = date.split('/');\n\n\t\t// Begin the object that we will return with the constitutent parts.\n\t\tvar dateObject = {};\n\n\t\t// First deal with number of repetitions, if any.\n\t\tif (date[0].substring(0, 1) === 'R') {\n\t\t\tvar recurrence = date[0].substring(1);\n\t\t\tif (recurrence === '') {\n\t\t\t\tdateObject.recurrence = Infinity;\n\t\t\t} else {\n\t\t\t\trecurrence = Number.parseInt(recurrence);\n\t\t\t\tif (!Number.isNaN(recurrence)) {\n\t\t\t\t\tdateObject.recurrence = recurrence;\n\t\t\t\t} else {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// The number of repetitions are then removed from the array.\n\t\t\tdate.shift();\n\t\t}\n\n\t\t// If we have a zero length array, it's only ok if there has been a\n\t\t// zero recurrence.\n\t\tif (date.length === 0) {\n\t\t\tif (dateObject.recurrence === 0) {\n\t\t\t\treturn dateObject;\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t// Make some prelimiary determinations about the first index of the array.\n\t\t// Here we build a moment Object ahead of time, and check the validity of the\n\t\t// first index as a date or interval.\n\t\tvar date0 = moment(date[0], moment.ISO_8601, true);\n\t\tvar isDate0 = date0.isValid();\n\t\tvar isInterval0 = (date[0].substring(0, 1) === 'P') && (moment.duration(date[0]) > 0);\n\n\t\tif (date.length === 2) {\n\t\t\t// If the lenght of the array is two, there is more to do. We make the same\n\t\t\t// preliminary determinations about the second index.\n\t\t\tvar date1 = moment(date[1], moment.ISO_8601, true);\n\t\t\tvar isDate1 = date1.isValid();\n\t\t\tvar isInterval1 = (date[1].substring(0, 1) === 'P') && (moment.duration(date[1]) > 0);\n\n\t\t\tif (isDate0 && isDate1) {\n\t\t\t\t// If they are both valid dates...\n\t\t\t\tif (date.recurrence) {\n\t\t\t\t\t// ... with a repetition that is invalid.\n\t\t\t\t\treturn false;\n\t\t\t\t} else {\n\t\t\t\t\t// ... we can turn the second date into a period.\n\t\t\t\t\tvar difference = date1.diff(date0);\n\n\t\t\t\t\tdateObject.date = date[0];\n\t\t\t\t\tdateObject.interval = moment.duration(difference).toJSON();\n\t\t\t\t\treturn dateObject;\n\t\t\t\t}\n\t\t\t} else if (isDate0 && isInterval1) {\n\t\t\t\t// If the first is a date and the second an interval, we have a basic\n\t\t\t\t// ISO8601 interval with a start date.\n\t\t\t\tdateObject.date = date[0];\n\t\t\t\tdateObject.interval = date[1];\n\t\t\t\treturn dateObject;\n\t\t\t} else if (isInterval0 && isDate1) {\n\t\t\t\t// If the first is an interval and the second is a date, we have a\n\t\t\t\t// more complicated interval with an end date. However, we can just\n\t\t\t\t// invert the sign on the interval and treat it like normal.\n\t\t\t\tdate1.subtract(moment.duration(date[0]));\n\n\t\t\t\tdateObject.date = date1.toISOString();\n\t\t\t\tdateObject.interval = date[0];\n\t\t\t\treturn dateObject;\n\t\t\t} else {\n\t\t\t\t// Any other form of a two-length array must be invalid.\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else if (date.length === 1) {\n\t\t\t// If the length of the array is one, we may be looking at some trivial dates.\n\t\t\tif (isDate0) {\n\t\t\t\t// If the value is a valid date...\n\t\t\t\tif (dateObject.recurrence) {\n\t\t\t\t\t// ... it is invalid with a repetition.\n\t\t\t\t\treturn false;\n\t\t\t\t} else {\n\t\t\t\t\t// ... we can just return it.\n\t\t\t\t\tdateObject.date = date0;\n\t\t\t\t\treturn dateObject;\n\t\t\t\t}\n\t\t\t} else if (isInterval0) {\n\t\t\t\t// An interval on its own is valid, as is it with a repetition.\n\t\t\t\tdateObject.interval = date[0];\n\t\t\t\treturn dateObject;\n\t\t\t} else {\n\t\t\t\t// All other formations are invalid.\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else {\n\t\t\t// Any other array lenghts at this stage are invalid.\n\t\t\treturn false;\n\t\t}\n\t}\n}\n"],"sourceRoot":"/source/"}